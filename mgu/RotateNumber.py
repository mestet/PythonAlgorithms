# (Жак Арсак. Программирование игр и головоломок.)
# Вращающееся число.
# Найти такое число n, оканчивающееся на цифру k, что, умножая n на k, мы получим новое число,
# полученное из n вычеркиванием цифры k на конце и приписыванием ее в начале.
# Строки/кортежи и иные последовательности не использовать.

# n * k = (n - k) / 10 + k * (10 ** p),
# n = k * ((10 ** (p + 1)) - 1) / (k * 10 - 1)

# 0 -> 0
# 1 -> 1
# 2 -> 105263157894736842
# 3 -> 1034482758620689655172413793
# 4 -> 102564
# 5 -> 102040816326530612244897959183673469387755
# 6 -> 1016949152542372881355932203389830508474576271186440677966
# 7 -> 1014492753623188405797
# 8 -> 1012658227848
# 9 -> 10112359550561797752808988764044943820224719


def woodoo_solution(k):
    x = 10 * k - 1
    a = []
    n = 0
    while k not in a:
        a += [k]
        p = 10 * k // x
        n = (n * 10) + p
        k = 10 * k % x
    print(str(k) + " -> " + str(n))


def almost_solution(k):
    i = 1
    x = ((k * 10 ** (i + 1)) - k ** 2) / (k * 10 - 1)
    while x != (int(x)):
        i += 1
        x = (k * (10 ** (i + 1)) - (k ** 2)) / ((k * 10) - 1)

    x = x * 10 + k
    print(x)


def my_solution(k):
    if k < 2:
        print(k)
        return
    for p in range(1, 100):
        a = k * ((10 ** (p + 1)) - 1)
        b = (k * 10 - 1)
        c = a % b
        if c == 0:
            print(a // b)
            break


my_solution(int(input("Enter a digit: ")))
